> [原文地址](https://zhuanlan.zhihu.com/p/388057431)

# 从根上理解用户态与内核态

本篇文章开始探秘用户态与内核态，虽然一般面试不会问这个，但搞清楚这块，对我们理解整个计算机系统是及其有意义的，这会让你在今后的学习中豁然开朗，你肯定会发出：“啊，原来如此的感叹！”

## 内容大纲

![img](https://pic3.zhimg.com/80/v2-a528a0c54f25bf78655a3f74a09b9606_1440w.webp)

## 小故事

张三是某科技公司的初级 Java 开发工程师（低权限），目前在 15 楼办公码代码，公司提供的资源仅有一套电脑（用户态），张三想着这一线的房价，倍感压力山大，于是给自己定下一个目标，一定要做技术总监，在一线扎根，奋斗 B 张三，奋斗 5 年终于当上了技术总监（高权限），之后张三搬到 30 楼，可以随时向资源部（系统调用）申请公司各种资源与获取公司的机密信息（内核态），所谓是走上人生巅峰。

通过这个故事，我们发现，低权限的资源范围较小，高权限的资源范围更大，所谓的「用户态与内核态只是不同权限的资源范围」。

## CPU 指令集权限

在说用户态与内核态之前，有必要说一下 `CPU 指令集`，指令集是 CPU 实现软件指挥硬件执行的媒介，具体来说每一条汇编语句都对应了一条 `CPU 指令`，而非常非常多的 `CPU 指令` 在一起，可以组成一个、甚至多个集合，指令的集合叫 `CPU 指令集`。

同时 `CPU 指令集` 有权限分级，大家试想，`CPU 指令集` 可以直接操作硬件的，要是因为指令操作的不规范`，造成的错误会影响整个计算机系统的。好比你写程序，因为对硬件操作不熟悉，导致操作系统内核、及其他所有正在运行的程序，都可能会因为操作失误而受到不可挽回的错误，最后只能重启计算机才行。

而对于硬件的操作是非常复杂的，参数众多，出问题的几率相当大，必须谨慎的进行操作，对开发人员来说是个艰巨的任务，还会增加负担，同时开发人员在这方面也不被信任，所以操作系统内核直接屏蔽开发人员对硬件操作的可能，都不让你碰到这些 `CPU 指令集`。

![img](https://pic3.zhimg.com/80/v2-506586ddee155b7c553e3d5cf660209e_1440w.webp)

针对上面的需求，硬件设备商直接提供硬件级别的支持，做法就是对 `CPU 指令集`设置了权限，不同级别权限能使用的 `CPU 指令集` 是有限的，以 Inter CPU 为例，Inter 把 `CPU 指令集` 操作的权限由高到低划为 4 级：

- ring 0
- ring 1
- ring 2
- ring 3

其中 ring 0 权限最高，可以使用所有 `CPU 指令集`，ring 3 权限最低，仅能使用常规 `CPU 指令集`，不能使用操作硬件资源的 `CPU 指令集`，比如 `I O` 读写、网卡访问、申请内存都不行，Linux 系统仅采用 ring 0 和 ring 3 这 2 个权限。

![img](https://pic3.zhimg.com/80/v2-7eb07a96e11e6da0cafd15edc82faa96_1440w.webp)

高情商

- ring 0 被叫做内核态，完全在操作系统内核中运行
- ring 3 被叫做用户态，在应用程序中运行

低情商

- 执行内核空间的代码，具有 ring 0 保护级别，有对硬件的所有操作权限，可以执行所有`CPU 指令集`，访问任意地址的内存，在内核模式下的任何异常都是灾难性的，将会导致整台机器停机
- 在用户模式下，具有 ring 3 保护级别，代码没有对硬件的直接控制权限，也不能直接访问地址的内存，程序是通过调用系统接口(System Call APIs)来达到访问硬件和内存，在这种保护模式下，即时程序发生崩溃也是可以恢复的，在电脑上大部分程序都是在，用户模式下运行的

## 用户态与内核态

通关了 CPU 指令集权限，现在再说用户态与内核态就十分简单了，用户态与内核态的概念就是 CPU 指令集权限的区别，进程中要读写 `I O`，必然会用到 ring 0 级别的 `CPU 指令集`，而此时 CPU 的指令集操作权限只有 ring 3，为了可以操作 ring 0 级别的 `CPU 指令集`，CPU 切换指令集操作权限级别为 ring 0，CPU 再执行相应的 ring 0 级别的 `CPU 指令集`（内核代码），执行的内核代码会使用当前进程的内核栈。

PS：每个进程都有两个栈，分别是用户栈与内核栈，对应用户态与内核态的使用

## 用户态与内核态的空间

在内存资源上的使用，操作系统对用户态与内核态也做了限制，每个进程创建都会分配「虚拟空间地址」（不懂可以参考我的另一篇文章“15 分钟！一文帮小白搞懂操作系统之内存”），以 Linux32 位操作系统为例，它的寻址空间范围是 `4G`（2 的 32 次方），而操作系统会把虚拟控制地址划分为两部分，一部分为内核空间，另一部分为用户空间，高位的 `1G`（从虚拟地址 0xC0000000 到 0xFFFFFFFF）由内核使用，而低位的 `3G`（从虚拟地址 0x00000000 到 0xBFFFFFFF）由各个进程使用。

![img](https://pic4.zhimg.com/80/v2-1870a0008929b2a66e2462db14200213_1440w.webp)

- 用户态：只能操作 `0-3G` 范围的低位虚拟空间地址
- 内核态：`0-4G` 范围的虚拟空间地址都可以操作，尤其是对 `3-4G` 范围的高位虚拟空间地址必须由内核态去操作
- 补充：`3G-4G` 部分大家是共享的（指所有进程的内核态逻辑地址是共享同一块内存地址），是内核态的地址空间，这里存放在整个内核的代码和所有的内核模块，以及内核所维护的数据

每个进程的 `4G` 虚拟空间地址，高位 `1G` 都是一样的，即内核空间。只有剩余的 `3G` 才归进程自己使用，换句话说就是，高位 `1G` 的内核空间是被所有进程共享的！

最后做个小结，我们通过指令集权限区分用户态和内核态，还限制了内存资源的使用，操作系统为用户态与内核态划分了两块内存空间，给它们对应的指令集使用

## 用户态与内核态的切换

相信大家都听过这样的话「用户态和内核态切换的开销大」，但是它的开销大在那里呢？简单点来说有下面几点

- 保留用户态现场（上下文、寄存器、用户栈等）
- 复制用户态参数，用户栈切到内核栈，进入内核态
- 额外的检查（因为内核代码对用户不信任）
- 执行内核态代码
- 复制内核态代码执行结果，回到用户态
- 恢复用户态现场（上下文、寄存器、用户栈等）

实际上操作系统会比上述的更复杂，这里只是个大概，我们可以发现一次切换经历了「用户态 -> 内核态 -> 用户态」。

用户态要主动切换到内核态，那必须要有入口才行，实际上内核态是提供了统一的入口，下面是 Linux 整体架构图

![img](https://pic1.zhimg.com/80/v2-62ff353fcfb90639ae2ec7aa5006b73c_1440w.webp)

从上图我们可以看出来通过系统调用将 Linux 整个体系分为用户态和内核态，为了使应用程序访问到内核的资源，如 CPU、内存、I/O，内核必须提供一组通用的访问接口，这些接口就叫系统调用。

库函数就是屏蔽这些复杂的底层实现细节，减轻程序员的负担，从而更加关注上层的逻辑实现，它对系统调用进行封装，提供简单的基本接口给程序员。

Shell 顾名思义，就是外壳的意思，就好像把内核包裹起来的外壳，它是一种特殊的应用程序，俗称命令行。Shell 也是可编程的，它有标准的 Shell 语法，符合其语法的文本叫 Shell 脚本，很多人都会用 Shell 脚本实现一些常用的功能，可以提高工作效率。

最后来说说，什么情况会导致用户态到内核态切换

- 系统调用：用户态进程主动切换到内核态的方式，用户态进程通过系统调用向操作系统申请资源完成工作，例如 fork（）就是一个创建新进程的系统调用，系统调用的机制核心使用了操作系统为用户特别开放的一个中断来实现，如 Linux 的 int 80h 中断，也可以称为软中断
- 异常：当 CPU 在执行用户态的进程时，发生了一些没有预知的异常，这时当前运行进程会切换到处理此异常的内核相关进程中，也就是切换到了内核态，如缺页异常
- 中断：当 CPU 在执行用户态的进程时，外围设备完成用户请求的操作后，会向 CPU 发出相应的中断信号，这时 CPU 会暂停执行下一条即将要执行的指令，转到与中断信号对应的处理程序去执行，也就是切换到了内核态。如硬盘读写操作完成，系统会切换到硬盘读写的中断处理程序中执行后边的操作等。

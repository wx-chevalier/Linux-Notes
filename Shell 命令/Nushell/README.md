# Nushell

Nu 汲取了很多常见领域的灵感：传统 Shell 比如 Bash、基于对象的 Shell 比如 PowerShell、逐步类型化的语言比如 TypeScript、函数式编程、系统编程，等等。但是，Nu 并不试图成为万金油，而是把精力集中在做好这几件事上:

- 作为一个具有现代感的灵活的跨平台 Shell；
- 作为一种现代的编程语言，解决与数据有关的问题；
- 给予清晰的错误信息和干净的 IDE 支持；

了解 Nu 能做什么的最简单的方法是从一些例子开始，所以让我们深入了解一下。

当你运行[`ls`](https://www.nushell.sh/commands/docs/ls.html)这样的命令时，你会注意到的第一件事是，你得到的不是一个文本块，而是一个结构化的表格：

```sh
> ls
╭────┬───────────────────────┬──────┬───────────┬─────────────╮
│ #  │         name          │ type │   size    │  modified   │
├────┼───────────────────────┼──────┼───────────┼─────────────┤
│  0 │ 404.html              │ file │     429 B │ 3 days ago  │
│  1 │ CONTRIBUTING.md       │ file │     955 B │ 8 mins ago  │
│  2 │ Gemfile               │ file │   1.1 KiB │ 3 days ago  │
│  3 │ Gemfile.lock          │ file │   6.9 KiB │ 3 days ago  │
│  4 │ LICENSE               │ file │   1.1 KiB │ 3 days ago  │
│  5 │ README.md             │ file │     213 B │ 3 days ago  │
```

该表不仅仅是以不同的方式显示目录，就像电子表格中的表一样，它还允许我们以更加互动的方式来处理数据。我们要做的第一件事是按大小对我们的表进行排序。要做到这一点，我们将从 ls 中获取输出，并将其输入到一个可以根据列的内容对表进行排序的命令中：

```sh
> ls | sort-by size | reverse
╭────┬───────────────────────┬──────┬───────────┬─────────────╮
│ #  │         name          │ type │   size    │  modified   │
├────┼───────────────────────┼──────┼───────────┼─────────────┤
│  0 │ Gemfile.lock          │ file │   6.9 KiB │ 3 days ago  │
│  1 │ SUMMARY.md            │ file │   3.7 KiB │ 3 days ago  │
│  2 │ Gemfile               │ file │   1.1 KiB │ 3 days ago  │
│  3 │ LICENSE               │ file │   1.1 KiB │ 3 days ago  │
│  4 │ CONTRIBUTING.md       │ file │     955 B │ 9 mins ago  │
│  5 │ books.md              │ file │     687 B │ 3 days ago  │
...
```

你可以看到，为了达到这个目的，我们没有向 ls 传递命令行参数。取而代之的是，我们使用了 Nu 提供的 sort-by 命令来对 ls 命令的输出进行排序。为了在顶部看到最大的文件，我们还使用了 reverse 命令。Nu 提供了许多可以对表进行操作的命令，例如，我们可以过滤 ls 表的内容，使其只显示超过 1 千字节的文件。

```sh
> ls | where size > 1kb
╭───┬───────────────────┬──────┬─────────┬────────────╮
│ # │       name        │ type │  size   │  modified  │
├───┼───────────────────┼──────┼─────────┼────────────┤
│ 0 │ Gemfile           │ file │ 1.1 KiB │ 3 days ago │
│ 1 │ Gemfile.lock      │ file │ 6.9 KiB │ 3 days ago │
│ 2 │ LICENSE           │ file │ 1.1 KiB │ 3 days ago │
│ 3 │ SUMMARY.md        │ file │ 3.7 KiB │ 3 days ago │
╰───┴───────────────────┴──────┴─────────┴────────────╯
```

就像在 Unix 哲学中一样，能够让命令相互对话给我们提供了在许多不同的组合中对命令进行混搭的方法。我们来看看一个不同的命令：

```sh
> ps
╭─────┬──────┬──────────────────────┬─────────┬───────┬───────────┬──────────╮
│  #  │ pid  │         name         │ status  │  cpu  │    mem    │ virtual  │
├─────┼──────┼──────────────────────┼─────────┼───────┼───────────┼──────────┤
│   0 │ 7570 │ nu                   │ Running │  1.96 │  23.2 MiB │ 32.8 GiB │
│   1 │ 3533 │ remindd              │ Sleep   │  0.00 │ 103.6 MiB │ 32.3 GiB │
│   2 │ 3495 │ TVCacheExtension     │ Sleep   │  0.00 │  11.9 MiB │ 32.2 GiB │
│   3 │ 3490 │ MusicCacheExtension  │ Sleep   │  0.00 │  12.9 MiB │ 32.2 GiB │
...
```

如果你使用过 Linux，你可能对 ps 命令很熟悉。通过它，我们可以得到一个当前系统正在运行的所有进程的列表，它们的状态是什么，以及它们的名字是什么，我们还可以看到这些进程的 CPU 负载。如果我们想显示那些正在活跃使用 CPU 的进程呢？就像我们之前对 ls 命令所做的那样，我们也可以利用 ps 命令返回给我们的表格来做到：

```sh
> ps | where cpu > 5
╭───┬──────┬────────────────┬─────────┬────────┬───────────┬──────────╮
│ # │ pid  │      name      │ status  │  cpu   │    mem    │ virtual  │
├───┼──────┼────────────────┼─────────┼────────┼───────────┼──────────┤
│ 0 │ 1583 │ Terminal       │ Running │  20.69 │ 127.8 MiB │ 33.0 GiB │
│ 1 │  579 │ photoanalysisd │ Running │ 139.50 │  99.9 MiB │ 32.3 GiB │
╰───┴──────┴────────────────┴─────────┴────────┴───────────┴──────────╯
```

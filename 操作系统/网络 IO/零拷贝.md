# 零拷贝

在写一个服务端程序时（Web Server 或者文件服务器），文件下载是一个基本功能。这时候服务端的任务是将服务端主机磁盘中的文件不做修改地从已连接的 Socket 发出去，我们通常用下面的代码完成：

```c
while((n = read(diskfd, buf, BUF_SIZE)) > 0)
    write(sockfd, buf , n);
```

基本操作就是循环的从磁盘读入文件内容到缓冲区，再将缓冲区的内容发送到 Socket。但是由于 Linux 的 IO 操作默认是缓冲 I/O，主要使用了 read 和 write 两个系统调用，在这两个系统调用之后，数据已经被复制了至少四次，并且几乎执行了同样次数的用户/内核空间的上下文切换。

![](https://s2.ax1x.com/2019/09/01/n9YNZV.png)

- read 系统调用导致上下文从用户模式切换到内核模式。第一个副本由 DMA 引擎执行，DMA 引擎从磁盘读取文件内容并将它们存储到内核地址空间缓冲区中。

- 将数据从内核缓冲区复制到用户缓冲区，并且 read 系统调用返回。read 调用返回导致上下文从内核切换回用户模式。现在数据存储在用户地址空间缓冲区中。

- write 系统调用导致上下文从用户模式切换到内核模式。执行第三次复制，以再次将数据放入内核地址空间缓冲区。这个时候，数据被放入一个不同的缓冲区，一个与 sockets 相关联的缓冲区。

- 写系统调用返回，创建我们的第四个上下文切换。独立和异步地，当 DMA 引擎将数据从内核缓冲区传递到协议引擎时，发生第四次复制。

独立和异步的意思是调用返回并不保证数据被传输；它甚至不保证传输的开始。它只是意味着以太网驱动程序在其队列中有空闲描述符，并接受我们的数据进行传输。在我们之前可能有许多数据包在排队。除非驱动器或硬件实现优先级环或队列，否则数据是以先进先出的方式传输的。

很多数据复制操作并不是真正需要的，可以消除一些复制操作以减少开销并提高性能，在此过程中，我们没有对文件内容做任何修改，那么在内核空间和用户空间来回拷贝数据无疑就是一种浪费，而零拷贝主要就是为了解决这种低效性。零拷贝主要的任务就是避免 CPU 将数据从一块存储拷贝到另外一块存储，主要就是利用各种零拷贝技术，避免让 CPU 做大量的数据拷贝任务，减少不必要的拷贝，或者让别的组件来做这一类简单的数据传输任务，让 CPU 解脱出来专注于别的任务。这样就可以让系统资源的利用更加有效。

# mmap

消除复制的一种方法是调用 mmap 来替代 read，譬如：

```c
tmp_buf = mmap(file, len);
write(socket, tmp_buf, len);
```

为了更好的理解处理过程，请看下图：上下文切换是一样的：

![](https://s2.ax1x.com/2019/09/01/n9t0Tf.png)

- mmap 系统调用导致 DMA 引擎将文件内容复制到内核缓冲区中。然后与用户进程共享缓冲区，而不在内核和用户存储器空间之间执行任何复制。

- write 系统调用导致内核将数据从原始内核缓冲区复制到与套接字相关联的内核缓冲区中。

- 当 DMA 引擎将数据从内核套接字缓冲区传递到协议引擎时，发生第三次复制。

使用 mmap 替代 read 很明显减少了一次拷贝，当拷贝数据量很大时，无疑提升了效率。但是使用 mmap 是有代价的。当你使用 mmap 时，你可能会遇到一些隐藏的陷阱。例如，当你的程序 map 了一个文件，但是当这个文件被另一个进程截断(truncate)时, write 系统调用会因为访问非法地址而被 SIGBUS 信号终止。SIGBUS 信号默认会杀死你的进程并产生一个 coredump,如果你的服务器这样被中止了，那会产生一笔损失。

通常我们使用以下解决方案避免这种问题：

- 为 SIGBUS 信号建立信号处理程序：当遇到 SIGBUS 信号时，信号处理程序简单地返回，write 系统调用在被中断之前会返回已经写入的字节数，并且 errno 会被设置成 success,但是这是一种糟糕的处理办法，因为你并没有解决问题的实质核心。

- 使用文件租借锁：通常我们使用这种方法，在文件描述符上使用租借锁，我们为文件向内核申请一个租借锁，当其它进程想要截断这个文件时，内核会向我们发送一个实时的 RT_SIGNAL_LEASE 信号，告诉我们内核正在破坏你加持在文件上的读写锁。这样在程序访问非法内存并且被 SIGBUS 杀死之前，你的 write 系统调用会被中断。write 会返回已经写入的字节数，并且置 errno 为 success。

我们应该在 mmap 文件之前加锁，并且在操作完文件后解锁：

```cpp
if(fcntl(diskfd, F_SETSIG, RT_SIGNAL_LEASE) == -1) {
    perror("kernel lease set signal");
    return -1;
}
/* l_type can be F_RDLCK F_WRLCK  加锁*/
/* l_type can be  F_UNLCK 解锁*/
if(fcntl(diskfd, F_SETLEASE, l_type)){
    perror("kernel lease set type");
    return -1;
}
```

# sendfile

在内核版本 2.1 中，引入了 sendfile 系统调用，以简化网络上和两个本地文件之间的数据传输。sendfile 的引入不仅减少了数据复制，还减少了上下文切换。使用如下：

```cpp
#include<sys/sendfile.h>

ssize_t sendfile(int out_fd, int in_fd, off_t *offset, size_t count);
```

系统调用 sendfile()在代表输入文件的描述符 in_fd 和代表输出文件的描述符 out_fd 之间传送文件内容（字节）。描述符 out_fd 必须指向一个套接字，而 in_fd 指向的文件必须是可以 mmap 的。这些局限限制了 sendfile 的使用，使 sendfile 只能将数据从文件传递到套接字上，反之则不行。使用 sendfile 不仅减少了数据拷贝的次数，还减少了上下文切换，数据传送始终只发生在 kernel space。

![](https://s2.ax1x.com/2019/09/01/n9NC1H.png)

- sendfile 系统调用导致文件内容被 DMA 引擎复制到内核缓冲区中。然后内核将数据复制到与套接字相关联的内核缓冲区中。

- 当 DMA 引擎将数据从内核套接字缓冲区传递到协议引擎时，发生第三次复制。

在我们调用 sendfile 时，如果有其它进程截断了文件会发生什么呢？假设我们没有设置任何信号处理程序，sendfile 调用仅仅返回它在被中断之前已经传输的字节数，errno 会被置为 success。如果我们在调用 sendfile 之前给文件加了锁，sendfile 的行为仍然和之前相同，我们还会收到 RT_SIGNAL_LEASE 的信号。

目前为止，我们已经减少了数据拷贝的次数了，但是仍然存在一次拷贝，就是页缓存到 socket 缓存的拷贝。那么能不能把这个拷贝也省略呢？
借助于硬件上的帮助，我们是可以办到的。之前我们是把页缓存的数据拷贝到 socket 缓存中，实际上，我们仅仅需要把缓冲区描述符传到 socket 缓冲区，再把数据长度传过去，这样 DMA 控制器直接将页缓存中的数据打包发送到网络中就可以了。即 sendfile 系统调用利用 DMA 引擎将文件内容拷贝到内核缓冲区去，然后将带有文件位置和长度信息的缓冲区描述符添加 socket 缓冲区去，这一步不会将内核中的数据拷贝到 socket 缓冲区中，DMA 引擎会将内核缓冲区的数据拷贝到协议引擎中去，避免了最后一次拷贝。

![](https://s2.ax1x.com/2019/09/01/n9NIbt.png)

- sendfile 系统调用导致文件内容被 DMA 引擎复制到内核缓冲区中。

- 没有数据被复制到套接字缓冲区。相反，只有关于数据的位置和长度的信息的描述符附加到套接字缓冲区。DMA 引擎将数据直接从内核缓冲区传递到协议引擎，从而消除最后剩下的一次内存拷贝。

因为数据实际上仍然是从磁盘复制到内存和从内存到电线，有些人可能认为这不是一个真正的零复制。但是，从操作系统的角度来看，这是零拷贝，因为数据不会在内核缓冲区之间来回拷贝。当使用零拷贝时，除了避免拷贝之外，还可以有其他性能优势，例如较少的上下文切换，较少的 CPU 缓存数据污染和没有 CPU 计算校验和的操作。并且这需要硬件的一点帮助，为了消除内核所做的所有数据复制，我们需要一个支持聚集操作的网络接口。这仅仅意味着等待传输的数据不需要在连续的内存空间中; 这些数据可以分散在存储器的各个位置。

# splice

sendfile 只适用于将数据从文件拷贝到套接字上，限定了它的使用范围。Linux 在 2.6.17 版本引入 splice 系统调用，用于在两个文件描述符中移动数据：

```cpp
#define _GNU_SOURCE         /* See feature_test_macros(7) */
#include <fcntl.h>
ssize_t splice(int fd_in, loff_t *off_in, int fd_out, loff_t *off_out, size_t len, unsigned int flags);
```

splice 调用在两个文件描述符之间移动数据，而不需要数据在内核空间和用户空间来回拷贝。他从 fd_in 拷贝 len 长度的数据到 fd_out，但是有一方必须是管道设备，这也是目前 splice 的一些局限性。flags 参数有以下几种取值：

- **SPLICE_F_MOVE**：尝试去移动数据而不是拷贝数据。这仅仅是对内核的一个小提示：如果内核不能从 pipe 移动数据或者 pipe 的缓存不是一个整页面，仍然需要拷贝数据。Linux 最初的实现有些问题，所以从 2.6.21 开始这个选项不起作用，后面的 Linux 版本应该会实现。

- **SPLICE_F_NONBLOCK**：splice 操作不会被阻塞。然而，如果文件描述符没有被设置为不可被阻塞方式的 IO，那么调用 splice 有可能仍然被阻塞。

- **SPLICE_F_MORE**：后面的 splice 调用会有更多的数据。

splice 调用利用了 Linux 提出的管道缓冲区机制，所以至少一个描述符要为管道。

# 总结

以上几种零拷贝技术都是减少数据在用户空间和内核空间拷贝技术实现的，但是有些时候，数据必须在用户空间和内核空间之间拷贝。这时候，我们只能针对数据在用户空间和内核空间拷贝的时机上下功夫了。Linux 通常利用写时复制(copy on write)来减少系统开销，这个技术又时常称作 COW。

如果多个程序同时访问同一块数据，那么每个程序都拥有指向这块数据的指针，在每个程序看来，自己都是独立拥有这块数据的，只有当程序需要对数据内容进行修改时，才会把数据内容拷贝到程序自己的应用空间里去，这时候，数据才成为该程序的私有数据。如果程序不需要对数据进行修改，那么永远都不需要拷贝数据到自己的应用空间里。这样就减少了数据的拷贝。

# TBD

- https://www.linuxjournal.com/article/6345
- https://www.jianshu.com/p/fad3339e3448
- https://zhuanlan.zhihu.com/p/76640160
- https://leokongwq.github.io/2017/01/12/linux-zero-copy.html
